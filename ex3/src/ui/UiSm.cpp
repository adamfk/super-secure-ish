// Autogenerated with StateSmith 0.18.2+6062baabb038910ff3841c3cd5938115c0ed0a03.
// Algorithm: Balanced2. See https://github.com/StateSmith/StateSmith/wiki/Algorithms

#include "UiSm.hpp"
#include <stdbool.h> // required for `consume_event` flag
#include <string.h> // for memset
#include "Display.hpp"
#define IDLE_TIMEOUT_MS (10 * 1000) // this works for C99 as well as C++11



// Starts the state machine. Must be called before dispatching events. Not thread safe.
void UiSm::start()
{
    ROOT_enter();
    // ROOT behavior
    // uml: TransitionTo(ROOT.<InitialState>)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `ROOT.<InitialState>`.
        // ROOT.<InitialState> is a pseudo state and cannot have an `enter` trigger.
        
        // ROOT.<InitialState> behavior
        // uml: TransitionTo(SPLASH_SCREEN)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `SPLASH_SCREEN`.
            SPLASH_SCREEN_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for ROOT.<InitialState>
    } // end of behavior for ROOT
}

// Dispatches an event to the state machine. Not thread safe.
// Note! This function assumes that the `eventId` parameter is valid.
void UiSm::dispatchEvent(EventId eventId)
{
    switch (this->stateId)
    {
        // STATE: UiSm
        case StateId::ROOT:
            switch (eventId)
            {
                case EventId::PANIC_BUTTON: ROOT_panic_button(); break;
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: HOME
        case StateId::HOME:
            switch (eventId)
            {
                case EventId::REFRESH: HOME_refresh(); break;
                case EventId::LCD_UPDATE: HOME_lcd_update(); break;
                case EventId::ENTER_PRESS: HOME_enter_press(); break;
                case EventId::PANIC_BUTTON: ROOT_panic_button(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: MENU
        case StateId::MENU:
            switch (eventId)
            {
                case EventId::ANY_KEY: MENU_any_key(); break;
                case EventId::BACK_PRESS: MENU_back_press(); break;
                case EventId::BACK_HELD: MENU_back_held(); break;
                case EventId::TIMEOUT: MENU_timeout(); break;
                case EventId::PANIC_BUTTON: ROOT_panic_button(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: ARM_SYSTEM
        case StateId::ARM_SYSTEM:
            switch (eventId)
            {
                case EventId::BACK_PRESS: ARM_SYSTEM_back_press(); break;
                case EventId::ENTER_PRESS: ARM_SYSTEM_enter_press(); break;
                case EventId::PANIC_BUTTON: ROOT_panic_button(); break; // First ancestor handler for this event
                case EventId::ANY_KEY: MENU_any_key(); break; // First ancestor handler for this event
                case EventId::BACK_HELD: MENU_back_held(); break; // First ancestor handler for this event
                case EventId::TIMEOUT: MENU_timeout(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: CONFIG
        case StateId::CONFIG:
            switch (eventId)
            {
                case EventId::BACK_PRESS: CONFIG_back_press(); break;
                case EventId::PANIC_BUTTON: ROOT_panic_button(); break; // First ancestor handler for this event
                case EventId::ANY_KEY: MENU_any_key(); break; // First ancestor handler for this event
                case EventId::BACK_HELD: MENU_back_held(); break; // First ancestor handler for this event
                case EventId::TIMEOUT: MENU_timeout(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: ALARM_DELAY
        case StateId::ALARM_DELAY:
            switch (eventId)
            {
                case EventId::BACK_PRESS: ALARM_DELAY_back_press(); break;
                case EventId::PANIC_BUTTON: ROOT_panic_button(); break; // First ancestor handler for this event
                case EventId::ANY_KEY: MENU_any_key(); break; // First ancestor handler for this event
                case EventId::BACK_HELD: MENU_back_held(); break; // First ancestor handler for this event
                case EventId::TIMEOUT: MENU_timeout(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: ARMING_DELAY
        case StateId::ARMING_DELAY:
            switch (eventId)
            {
                case EventId::BACK_PRESS: ARMING_DELAY_back_press(); break;
                case EventId::PANIC_BUTTON: ROOT_panic_button(); break; // First ancestor handler for this event
                case EventId::ANY_KEY: MENU_any_key(); break; // First ancestor handler for this event
                case EventId::BACK_HELD: MENU_back_held(); break; // First ancestor handler for this event
                case EventId::TIMEOUT: MENU_timeout(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: CHANGE_CODE
        case StateId::CHANGE_CODE:
            switch (eventId)
            {
                case EventId::BACK_PRESS: CHANGE_CODE_back_press(); break;
                case EventId::UP_DOWN_HELD: CHANGE_CODE_up_down_held(); break;
                case EventId::PANIC_BUTTON: ROOT_panic_button(); break; // First ancestor handler for this event
                case EventId::ANY_KEY: MENU_any_key(); break; // First ancestor handler for this event
                case EventId::BACK_HELD: MENU_back_held(); break; // First ancestor handler for this event
                case EventId::TIMEOUT: MENU_timeout(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: CONFIG__ALARM_DELAY
        case StateId::CONFIG__ALARM_DELAY:
            switch (eventId)
            {
                case EventId::UP_PRESS: CONFIG__ALARM_DELAY_up_press(); break;
                case EventId::ENTER_PRESS: CONFIG__ALARM_DELAY_enter_press(); break;
                case EventId::PANIC_BUTTON: ROOT_panic_button(); break; // First ancestor handler for this event
                case EventId::ANY_KEY: MENU_any_key(); break; // First ancestor handler for this event
                case EventId::BACK_PRESS: CONFIG_back_press(); break; // First ancestor handler for this event
                case EventId::BACK_HELD: MENU_back_held(); break; // First ancestor handler for this event
                case EventId::TIMEOUT: MENU_timeout(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: CONFIG__ARMING_DELAY
        case StateId::CONFIG__ARMING_DELAY:
            switch (eventId)
            {
                case EventId::DOWN_PRESS: CONFIG__ARMING_DELAY_down_press(); break;
                case EventId::UP_PRESS: CONFIG__ARMING_DELAY_up_press(); break;
                case EventId::ENTER_PRESS: CONFIG__ARMING_DELAY_enter_press(); break;
                case EventId::PANIC_BUTTON: ROOT_panic_button(); break; // First ancestor handler for this event
                case EventId::ANY_KEY: MENU_any_key(); break; // First ancestor handler for this event
                case EventId::BACK_PRESS: CONFIG_back_press(); break; // First ancestor handler for this event
                case EventId::BACK_HELD: MENU_back_held(); break; // First ancestor handler for this event
                case EventId::TIMEOUT: MENU_timeout(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: CONFIG__CHANGE_CODE
        case StateId::CONFIG__CHANGE_CODE:
            switch (eventId)
            {
                case EventId::DOWN_PRESS: CONFIG__CHANGE_CODE_down_press(); break;
                case EventId::ENTER_PRESS: CONFIG__CHANGE_CODE_enter_press(); break;
                case EventId::PANIC_BUTTON: ROOT_panic_button(); break; // First ancestor handler for this event
                case EventId::ANY_KEY: MENU_any_key(); break; // First ancestor handler for this event
                case EventId::BACK_PRESS: CONFIG_back_press(); break; // First ancestor handler for this event
                case EventId::BACK_HELD: MENU_back_held(); break; // First ancestor handler for this event
                case EventId::TIMEOUT: MENU_timeout(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: SECRET_MENU
        case StateId::SECRET_MENU:
            switch (eventId)
            {
                case EventId::LCD_UPDATE: SECRET_MENU_lcd_update(); break;
                case EventId::UP_PRESS: SECRET_MENU_up_press(); break;
                case EventId::DOWN_PRESS: SECRET_MENU_down_press(); break;
                case EventId::BACK_PRESS: SECRET_MENU_back_press(); break;
                case EventId::ENTER_PRESS: SECRET_MENU_enter_press(); break;
                case EventId::PANIC_BUTTON: ROOT_panic_button(); break; // First ancestor handler for this event
                case EventId::ANY_KEY: MENU_any_key(); break; // First ancestor handler for this event
                case EventId::BACK_HELD: MENU_back_held(); break; // First ancestor handler for this event
                case EventId::TIMEOUT: MENU_timeout(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: DATA
        case StateId::DATA:
            switch (eventId)
            {
                case EventId::ANY_KEY: DATA_any_key(); break;
                case EventId::BACK_PRESS: DATA_back_press(); break;
                case EventId::PANIC_BUTTON: ROOT_panic_button(); break; // First ancestor handler for this event
                case EventId::BACK_HELD: MENU_back_held(); break; // First ancestor handler for this event
                case EventId::TIMEOUT: MENU_timeout(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: SENSOR
        case StateId::SENSOR:
            switch (eventId)
            {
                case EventId::LCD_UPDATE: SENSOR_lcd_update(); break;
                case EventId::UP_PRESS: SENSOR_up_press(); break;
                case EventId::PANIC_BUTTON: ROOT_panic_button(); break; // First ancestor handler for this event
                case EventId::ANY_KEY: DATA_any_key(); break; // First ancestor handler for this event
                case EventId::BACK_PRESS: DATA_back_press(); break; // First ancestor handler for this event
                case EventId::BACK_HELD: MENU_back_held(); break; // First ancestor handler for this event
                case EventId::TIMEOUT: MENU_timeout(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: UPTIME
        case StateId::UPTIME:
            switch (eventId)
            {
                case EventId::LCD_UPDATE: UPTIME_lcd_update(); break;
                case EventId::DOWN_PRESS: UPTIME_down_press(); break;
                case EventId::PANIC_BUTTON: ROOT_panic_button(); break; // First ancestor handler for this event
                case EventId::ANY_KEY: DATA_any_key(); break; // First ancestor handler for this event
                case EventId::BACK_PRESS: DATA_back_press(); break; // First ancestor handler for this event
                case EventId::BACK_HELD: MENU_back_held(); break; // First ancestor handler for this event
                case EventId::TIMEOUT: MENU_timeout(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: DISARM_SYSTEM
        case StateId::DISARM_SYSTEM:
            switch (eventId)
            {
                case EventId::BACK_PRESS: DISARM_SYSTEM_back_press(); break;
                case EventId::ENTER_PRESS: DISARM_SYSTEM_enter_press(); break;
                case EventId::PANIC_BUTTON: ROOT_panic_button(); break; // First ancestor handler for this event
                case EventId::ANY_KEY: MENU_any_key(); break; // First ancestor handler for this event
                case EventId::BACK_HELD: MENU_back_held(); break; // First ancestor handler for this event
                case EventId::TIMEOUT: MENU_timeout(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: MENU__ARM_SYSTEM
        case StateId::MENU__ARM_SYSTEM:
            switch (eventId)
            {
                case EventId::DOWN_PRESS: MENU__ARM_SYSTEM_down_press(); break;
                case EventId::UP_PRESS: MENU__ARM_SYSTEM_up_press(); break;
                case EventId::ENTER_PRESS: MENU__ARM_SYSTEM_enter_press(); break;
                case EventId::PANIC_BUTTON: ROOT_panic_button(); break; // First ancestor handler for this event
                case EventId::ANY_KEY: MENU_any_key(); break; // First ancestor handler for this event
                case EventId::BACK_PRESS: MENU_back_press(); break; // First ancestor handler for this event
                case EventId::BACK_HELD: MENU_back_held(); break; // First ancestor handler for this event
                case EventId::TIMEOUT: MENU_timeout(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: MENU__CONFIG
        case StateId::MENU__CONFIG:
            switch (eventId)
            {
                case EventId::DOWN_PRESS: MENU__CONFIG_down_press(); break;
                case EventId::UP_PRESS: MENU__CONFIG_up_press(); break;
                case EventId::ENTER_PRESS: MENU__CONFIG_enter_press(); break;
                case EventId::PANIC_BUTTON: ROOT_panic_button(); break; // First ancestor handler for this event
                case EventId::ANY_KEY: MENU_any_key(); break; // First ancestor handler for this event
                case EventId::BACK_PRESS: MENU_back_press(); break; // First ancestor handler for this event
                case EventId::BACK_HELD: MENU_back_held(); break; // First ancestor handler for this event
                case EventId::TIMEOUT: MENU_timeout(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: MENU__DATA
        case StateId::MENU__DATA:
            switch (eventId)
            {
                case EventId::UP_PRESS: MENU__DATA_up_press(); break;
                case EventId::ENTER_PRESS: MENU__DATA_enter_press(); break;
                case EventId::PANIC_BUTTON: ROOT_panic_button(); break; // First ancestor handler for this event
                case EventId::ANY_KEY: MENU_any_key(); break; // First ancestor handler for this event
                case EventId::BACK_PRESS: MENU_back_press(); break; // First ancestor handler for this event
                case EventId::BACK_HELD: MENU_back_held(); break; // First ancestor handler for this event
                case EventId::TIMEOUT: MENU_timeout(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: MENU__DISARM_SYSTEM
        case StateId::MENU__DISARM_SYSTEM:
            switch (eventId)
            {
                case EventId::DOWN_PRESS: MENU__DISARM_SYSTEM_down_press(); break;
                case EventId::ENTER_PRESS: MENU__DISARM_SYSTEM_enter_press(); break;
                case EventId::PANIC_BUTTON: ROOT_panic_button(); break; // First ancestor handler for this event
                case EventId::ANY_KEY: MENU_any_key(); break; // First ancestor handler for this event
                case EventId::BACK_PRESS: MENU_back_press(); break; // First ancestor handler for this event
                case EventId::BACK_HELD: MENU_back_held(); break; // First ancestor handler for this event
                case EventId::TIMEOUT: MENU_timeout(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: PANIC
        case StateId::PANIC:
            switch (eventId)
            {
                case EventId::TIMEOUT: PANIC_timeout(); break;
                case EventId::PANIC_BUTTON: ROOT_panic_button(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: SPLASH_SCREEN
        case StateId::SPLASH_SCREEN:
            switch (eventId)
            {
                case EventId::TIMEOUT: SPLASH_SCREEN_timeout(); break;
                case EventId::PANIC_BUTTON: ROOT_panic_button(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
    }
    
}

// This function is used when StateSmith doesn't know what the active leaf state is at
// compile time due to sub states or when multiple states need to be exited.
void UiSm::exitUpToStateHandler(StateId desiredState)
{
    while (this->stateId != desiredState)
    {
        switch (this->stateId)
        {
            case StateId::HOME: HOME_exit(); break;
            
            case StateId::MENU: MENU_exit(); break;
            
            case StateId::ARM_SYSTEM: ARM_SYSTEM_exit(); break;
            
            case StateId::CONFIG: CONFIG_exit(); break;
            
            case StateId::ALARM_DELAY: ALARM_DELAY_exit(); break;
            
            case StateId::ARMING_DELAY: ARMING_DELAY_exit(); break;
            
            case StateId::CHANGE_CODE: CHANGE_CODE_exit(); break;
            
            case StateId::CONFIG__ALARM_DELAY: CONFIG__ALARM_DELAY_exit(); break;
            
            case StateId::CONFIG__ARMING_DELAY: CONFIG__ARMING_DELAY_exit(); break;
            
            case StateId::CONFIG__CHANGE_CODE: CONFIG__CHANGE_CODE_exit(); break;
            
            case StateId::SECRET_MENU: SECRET_MENU_exit(); break;
            
            case StateId::DATA: DATA_exit(); break;
            
            case StateId::SENSOR: SENSOR_exit(); break;
            
            case StateId::UPTIME: UPTIME_exit(); break;
            
            case StateId::DISARM_SYSTEM: DISARM_SYSTEM_exit(); break;
            
            case StateId::MENU__ARM_SYSTEM: MENU__ARM_SYSTEM_exit(); break;
            
            case StateId::MENU__CONFIG: MENU__CONFIG_exit(); break;
            
            case StateId::MENU__DATA: MENU__DATA_exit(); break;
            
            case StateId::MENU__DISARM_SYSTEM: MENU__DISARM_SYSTEM_exit(); break;
            
            case StateId::PANIC: PANIC_exit(); break;
            
            case StateId::SPLASH_SCREEN: SPLASH_SCREEN_exit(); break;
            
            default: return;  // Just to be safe. Prevents infinite loop if state ID memory is somehow corrupted.
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state ROOT
////////////////////////////////////////////////////////////////////////////////

void UiSm::ROOT_enter()
{
    this->stateId = StateId::ROOT;
}

void UiSm::ROOT_panic_button()
{
    // ROOT behavior
    // uml: PANIC_BUTTON TransitionTo(PANIC)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::ROOT);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `PANIC`.
        PANIC_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for ROOT
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state HOME
////////////////////////////////////////////////////////////////////////////////

void UiSm::HOME_enter()
{
    this->stateId = StateId::HOME;
    
    // HOME behavior
    // uml: (enter, REFRESH) / { lcd->HOME(); }
    {
        // Step 1: execute action `lcd->HOME();`
        this->vars.lcd->HOME();
    } // end of behavior for HOME
}

void UiSm::HOME_exit()
{
    this->stateId = StateId::ROOT;
}

void UiSm::HOME_enter_press()
{
    // HOME behavior
    // uml: ENTER_PRESS TransitionTo(MENU)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        HOME_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `MENU`.
        MENU_enter();
        
        // MENU.<InitialState> behavior
        // uml: TransitionTo(MENU__DISARM_SYSTEM)
        {
            // Step 1: Exit states until we reach `MENU` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `MENU__DISARM_SYSTEM`.
            MENU__DISARM_SYSTEM_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for MENU.<InitialState>
    } // end of behavior for HOME
    
    // No ancestor handles this event.
}

void UiSm::HOME_lcd_update()
{
    // HOME behavior
    // uml: LCD_UPDATE / { lcd->HOME_update(); }
    {
        // Step 1: execute action `lcd->HOME_update();`
        this->vars.lcd->HOME_update();
    } // end of behavior for HOME
    
    // No ancestor handles this event.
}

void UiSm::HOME_refresh()
{
    // HOME behavior
    // uml: (enter, REFRESH) / { lcd->HOME(); }
    {
        // Step 1: execute action `lcd->HOME();`
        this->vars.lcd->HOME();
    } // end of behavior for HOME
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state MENU
////////////////////////////////////////////////////////////////////////////////

void UiSm::MENU_enter()
{
    this->stateId = StateId::MENU;
    
    // MENU behavior
    // uml: (enter, ANY_KEY) / { timeout_ms = IDLE_TIMEOUT_MS; }
    {
        // Step 1: execute action `timeout_ms = IDLE_TIMEOUT_MS;`
        this->vars.timeout_ms = IDLE_TIMEOUT_MS;
    } // end of behavior for MENU
}

void UiSm::MENU_exit()
{
    this->stateId = StateId::ROOT;
}

void UiSm::MENU_any_key()
{
    // MENU behavior
    // uml: (enter, ANY_KEY) / { timeout_ms = IDLE_TIMEOUT_MS; }
    {
        // Step 1: execute action `timeout_ms = IDLE_TIMEOUT_MS;`
        this->vars.timeout_ms = IDLE_TIMEOUT_MS;
    } // end of behavior for MENU
    
    // No ancestor handles this event.
}

void UiSm::MENU_back_held()
{
    // MENU behavior
    // uml: (BACK_PRESS, BACK_HELD, TIMEOUT) TransitionTo(HOME)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::ROOT);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `HOME`.
        HOME_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for MENU
    
    // No ancestor handles this event.
}

void UiSm::MENU_back_press()
{
    // MENU behavior
    // uml: (BACK_PRESS, BACK_HELD, TIMEOUT) TransitionTo(HOME)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::ROOT);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `HOME`.
        HOME_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for MENU
    
    // No ancestor handles this event.
}

void UiSm::MENU_timeout()
{
    // MENU behavior
    // uml: (BACK_PRESS, BACK_HELD, TIMEOUT) TransitionTo(HOME)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::ROOT);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `HOME`.
        HOME_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for MENU
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state ARM_SYSTEM
////////////////////////////////////////////////////////////////////////////////

void UiSm::ARM_SYSTEM_enter()
{
    this->stateId = StateId::ARM_SYSTEM;
    
    // ARM_SYSTEM behavior
    // uml: enter / { lcd->ARM_SYSTEM(); }
    {
        // Step 1: execute action `lcd->ARM_SYSTEM();`
        this->vars.lcd->ARM_SYSTEM();
    } // end of behavior for ARM_SYSTEM
}

void UiSm::ARM_SYSTEM_exit()
{
    this->stateId = StateId::MENU;
}

void UiSm::ARM_SYSTEM_back_press()
{
    bool consume_event = false;
    
    // ARM_SYSTEM behavior
    // uml: BACK_PRESS TransitionTo(MENU__ARM_SYSTEM)
    {
        // Step 1: Exit states until we reach `MENU` state (Least Common Ancestor for transition).
        ARM_SYSTEM_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `MENU__ARM_SYSTEM`.
        MENU__ARM_SYSTEM_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for ARM_SYSTEM
    
    // Check if event has been consumed before calling ancestor handler.
    if (!consume_event)
    {
        MENU_back_press();
    }
}

void UiSm::ARM_SYSTEM_enter_press()
{
    // ARM_SYSTEM behavior
    // uml: ENTER_PRESS / { ctrl->arm(); } TransitionTo(HOME)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::ROOT);
        
        // Step 2: Transition action: `ctrl->arm();`.
        this->vars.ctrl->arm();
        
        // Step 3: Enter/move towards transition target `HOME`.
        HOME_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for ARM_SYSTEM
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state CONFIG
////////////////////////////////////////////////////////////////////////////////

void UiSm::CONFIG_enter()
{
    this->stateId = StateId::CONFIG;
}

void UiSm::CONFIG_exit()
{
    this->stateId = StateId::MENU;
}

void UiSm::CONFIG_back_press()
{
    bool consume_event = false;
    
    // CONFIG behavior
    // uml: BACK_PRESS TransitionTo(MENU__CONFIG)
    {
        // Step 1: Exit states until we reach `MENU` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::MENU);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `MENU__CONFIG`.
        MENU__CONFIG_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for CONFIG
    
    // Check if event has been consumed before calling ancestor handler.
    if (!consume_event)
    {
        MENU_back_press();
    }
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state ALARM_DELAY
////////////////////////////////////////////////////////////////////////////////

void UiSm::ALARM_DELAY_enter()
{
    this->stateId = StateId::ALARM_DELAY;
    
    // ALARM_DELAY behavior
    // uml: enter / { lcd->ALARM_DELAY(); }
    {
        // Step 1: execute action `lcd->ALARM_DELAY();`
        this->vars.lcd->ALARM_DELAY();
    } // end of behavior for ALARM_DELAY
}

void UiSm::ALARM_DELAY_exit()
{
    this->stateId = StateId::CONFIG;
}

void UiSm::ALARM_DELAY_back_press()
{
    bool consume_event = false;
    
    // ALARM_DELAY behavior
    // uml: BACK_PRESS TransitionTo(CONFIG__ALARM_DELAY)
    {
        // Step 1: Exit states until we reach `CONFIG` state (Least Common Ancestor for transition).
        ALARM_DELAY_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CONFIG__ALARM_DELAY`.
        CONFIG__ALARM_DELAY_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for ALARM_DELAY
    
    // Check if event has been consumed before calling ancestor handler.
    if (!consume_event)
    {
        CONFIG_back_press();
    }
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state ARMING_DELAY
////////////////////////////////////////////////////////////////////////////////

void UiSm::ARMING_DELAY_enter()
{
    this->stateId = StateId::ARMING_DELAY;
    
    // ARMING_DELAY behavior
    // uml: enter / { lcd->ARMING_DELAY(); }
    {
        // Step 1: execute action `lcd->ARMING_DELAY();`
        this->vars.lcd->ARMING_DELAY();
    } // end of behavior for ARMING_DELAY
}

void UiSm::ARMING_DELAY_exit()
{
    this->stateId = StateId::CONFIG;
}

void UiSm::ARMING_DELAY_back_press()
{
    bool consume_event = false;
    
    // ARMING_DELAY behavior
    // uml: BACK_PRESS TransitionTo(CONFIG__ARMING_DELAY)
    {
        // Step 1: Exit states until we reach `CONFIG` state (Least Common Ancestor for transition).
        ARMING_DELAY_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CONFIG__ARMING_DELAY`.
        CONFIG__ARMING_DELAY_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for ARMING_DELAY
    
    // Check if event has been consumed before calling ancestor handler.
    if (!consume_event)
    {
        CONFIG_back_press();
    }
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state CHANGE_CODE
////////////////////////////////////////////////////////////////////////////////

void UiSm::CHANGE_CODE_enter()
{
    this->stateId = StateId::CHANGE_CODE;
    
    // CHANGE_CODE behavior
    // uml: enter / { lcd->CHANGE_CODE(); }
    {
        // Step 1: execute action `lcd->CHANGE_CODE();`
        this->vars.lcd->CHANGE_CODE();
    } // end of behavior for CHANGE_CODE
}

void UiSm::CHANGE_CODE_exit()
{
    this->stateId = StateId::CONFIG;
}

void UiSm::CHANGE_CODE_back_press()
{
    bool consume_event = false;
    
    // CHANGE_CODE behavior
    // uml: BACK_PRESS TransitionTo(CONFIG__CHANGE_CODE)
    {
        // Step 1: Exit states until we reach `CONFIG` state (Least Common Ancestor for transition).
        CHANGE_CODE_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CONFIG__CHANGE_CODE`.
        CONFIG__CHANGE_CODE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for CHANGE_CODE
    
    // Check if event has been consumed before calling ancestor handler.
    if (!consume_event)
    {
        CONFIG_back_press();
    }
}

void UiSm::CHANGE_CODE_up_down_held()
{
    // CHANGE_CODE behavior
    // uml: UP_DOWN_HELD TransitionTo(SECRET_MENU)
    {
        // Step 1: Exit states until we reach `CONFIG` state (Least Common Ancestor for transition).
        CHANGE_CODE_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `SECRET_MENU`.
        SECRET_MENU_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for CHANGE_CODE
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state CONFIG__ALARM_DELAY
////////////////////////////////////////////////////////////////////////////////

void UiSm::CONFIG__ALARM_DELAY_enter()
{
    this->stateId = StateId::CONFIG__ALARM_DELAY;
    
    // CONFIG__ALARM_DELAY behavior
    // uml: enter / { lcd->CONFIG__ALARM_DELAY(); }
    {
        // Step 1: execute action `lcd->CONFIG__ALARM_DELAY();`
        this->vars.lcd->CONFIG__ALARM_DELAY();
    } // end of behavior for CONFIG__ALARM_DELAY
}

void UiSm::CONFIG__ALARM_DELAY_exit()
{
    this->stateId = StateId::CONFIG;
}

void UiSm::CONFIG__ALARM_DELAY_enter_press()
{
    // CONFIG__ALARM_DELAY behavior
    // uml: ENTER_PRESS TransitionTo(ALARM_DELAY)
    {
        // Step 1: Exit states until we reach `CONFIG` state (Least Common Ancestor for transition).
        CONFIG__ALARM_DELAY_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `ALARM_DELAY`.
        ALARM_DELAY_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for CONFIG__ALARM_DELAY
    
    // No ancestor handles this event.
}

void UiSm::CONFIG__ALARM_DELAY_up_press()
{
    // CONFIG__ALARM_DELAY behavior
    // uml: UP_PRESS TransitionTo(CONFIG__ARMING_DELAY)
    {
        // Step 1: Exit states until we reach `CONFIG` state (Least Common Ancestor for transition).
        CONFIG__ALARM_DELAY_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CONFIG__ARMING_DELAY`.
        CONFIG__ARMING_DELAY_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for CONFIG__ALARM_DELAY
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state CONFIG__ARMING_DELAY
////////////////////////////////////////////////////////////////////////////////

void UiSm::CONFIG__ARMING_DELAY_enter()
{
    this->stateId = StateId::CONFIG__ARMING_DELAY;
    
    // CONFIG__ARMING_DELAY behavior
    // uml: enter / { lcd->CONFIG__ARMING_DELAY(); }
    {
        // Step 1: execute action `lcd->CONFIG__ARMING_DELAY();`
        this->vars.lcd->CONFIG__ARMING_DELAY();
    } // end of behavior for CONFIG__ARMING_DELAY
}

void UiSm::CONFIG__ARMING_DELAY_exit()
{
    this->stateId = StateId::CONFIG;
}

void UiSm::CONFIG__ARMING_DELAY_down_press()
{
    // CONFIG__ARMING_DELAY behavior
    // uml: DOWN_PRESS TransitionTo(CONFIG__ALARM_DELAY)
    {
        // Step 1: Exit states until we reach `CONFIG` state (Least Common Ancestor for transition).
        CONFIG__ARMING_DELAY_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CONFIG__ALARM_DELAY`.
        CONFIG__ALARM_DELAY_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for CONFIG__ARMING_DELAY
    
    // No ancestor handles this event.
}

void UiSm::CONFIG__ARMING_DELAY_enter_press()
{
    // CONFIG__ARMING_DELAY behavior
    // uml: ENTER_PRESS TransitionTo(ARMING_DELAY)
    {
        // Step 1: Exit states until we reach `CONFIG` state (Least Common Ancestor for transition).
        CONFIG__ARMING_DELAY_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `ARMING_DELAY`.
        ARMING_DELAY_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for CONFIG__ARMING_DELAY
    
    // No ancestor handles this event.
}

void UiSm::CONFIG__ARMING_DELAY_up_press()
{
    // CONFIG__ARMING_DELAY behavior
    // uml: UP_PRESS TransitionTo(CONFIG__CHANGE_CODE)
    {
        // Step 1: Exit states until we reach `CONFIG` state (Least Common Ancestor for transition).
        CONFIG__ARMING_DELAY_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CONFIG__CHANGE_CODE`.
        CONFIG__CHANGE_CODE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for CONFIG__ARMING_DELAY
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state CONFIG__CHANGE_CODE
////////////////////////////////////////////////////////////////////////////////

void UiSm::CONFIG__CHANGE_CODE_enter()
{
    this->stateId = StateId::CONFIG__CHANGE_CODE;
    
    // CONFIG__CHANGE_CODE behavior
    // uml: enter / { lcd->CONFIG__CHANGE_CODE(); }
    {
        // Step 1: execute action `lcd->CONFIG__CHANGE_CODE();`
        this->vars.lcd->CONFIG__CHANGE_CODE();
    } // end of behavior for CONFIG__CHANGE_CODE
}

void UiSm::CONFIG__CHANGE_CODE_exit()
{
    this->stateId = StateId::CONFIG;
}

void UiSm::CONFIG__CHANGE_CODE_down_press()
{
    // CONFIG__CHANGE_CODE behavior
    // uml: DOWN_PRESS TransitionTo(CONFIG__ARMING_DELAY)
    {
        // Step 1: Exit states until we reach `CONFIG` state (Least Common Ancestor for transition).
        CONFIG__CHANGE_CODE_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CONFIG__ARMING_DELAY`.
        CONFIG__ARMING_DELAY_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for CONFIG__CHANGE_CODE
    
    // No ancestor handles this event.
}

void UiSm::CONFIG__CHANGE_CODE_enter_press()
{
    // CONFIG__CHANGE_CODE behavior
    // uml: ENTER_PRESS TransitionTo(CHANGE_CODE)
    {
        // Step 1: Exit states until we reach `CONFIG` state (Least Common Ancestor for transition).
        CONFIG__CHANGE_CODE_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CHANGE_CODE`.
        CHANGE_CODE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for CONFIG__CHANGE_CODE
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state SECRET_MENU
////////////////////////////////////////////////////////////////////////////////

void UiSm::SECRET_MENU_enter()
{
    this->stateId = StateId::SECRET_MENU;
    
    // SECRET_MENU behavior
    // uml: enter / { lcd->SECRET_MENU(); }
    {
        // Step 1: execute action `lcd->SECRET_MENU();`
        this->vars.lcd->SECRET_MENU();
    } // end of behavior for SECRET_MENU
    
    // SECRET_MENU behavior
    // uml: enter / { audio->play_secret(); }
    {
        // Step 1: execute action `audio->play_secret();`
        this->vars.audio->play_secret();
    } // end of behavior for SECRET_MENU
}

void UiSm::SECRET_MENU_exit()
{
    this->stateId = StateId::CONFIG;
}

void UiSm::SECRET_MENU_back_press()
{
    bool consume_event = false;
    
    // SECRET_MENU behavior
    // uml: (UP_PRESS, DOWN_PRESS, BACK_PRESS, ENTER_PRESS) / { lcd->SECRET_MENU_button(event_id); }
    {
        // Consume event `back_press`.
        consume_event = true;
        // Step 1: execute action `lcd->SECRET_MENU_button(event_id);`
        this->vars.lcd->SECRET_MENU_button(this->vars.event_id);
    } // end of behavior for SECRET_MENU
    
    // Check if event has been consumed before calling ancestor handler.
    if (!consume_event)
    {
        CONFIG_back_press();
    }
}

void UiSm::SECRET_MENU_down_press()
{
    // SECRET_MENU behavior
    // uml: (UP_PRESS, DOWN_PRESS, BACK_PRESS, ENTER_PRESS) / { lcd->SECRET_MENU_button(event_id); }
    {
        // Step 1: execute action `lcd->SECRET_MENU_button(event_id);`
        this->vars.lcd->SECRET_MENU_button(this->vars.event_id);
    } // end of behavior for SECRET_MENU
    
    // No ancestor handles this event.
}

void UiSm::SECRET_MENU_enter_press()
{
    // SECRET_MENU behavior
    // uml: (UP_PRESS, DOWN_PRESS, BACK_PRESS, ENTER_PRESS) / { lcd->SECRET_MENU_button(event_id); }
    {
        // Step 1: execute action `lcd->SECRET_MENU_button(event_id);`
        this->vars.lcd->SECRET_MENU_button(this->vars.event_id);
    } // end of behavior for SECRET_MENU
    
    // No ancestor handles this event.
}

void UiSm::SECRET_MENU_lcd_update()
{
    // SECRET_MENU behavior
    // uml: LCD_UPDATE / { lcd->SECRET_MENU_update(); }
    {
        // Step 1: execute action `lcd->SECRET_MENU_update();`
        this->vars.lcd->SECRET_MENU_update();
    } // end of behavior for SECRET_MENU
    
    // SECRET_MENU behavior
    // uml: LCD_UPDATE / { timeout_ms = IDLE_TIMEOUT_MS; /* disable timeout */ }
    {
        // Step 1: execute action `timeout_ms = IDLE_TIMEOUT_MS; /* disable timeout */`
        this->vars.timeout_ms = IDLE_TIMEOUT_MS; /* disable timeout */
    } // end of behavior for SECRET_MENU
    
    // No ancestor handles this event.
}

void UiSm::SECRET_MENU_up_press()
{
    // SECRET_MENU behavior
    // uml: (UP_PRESS, DOWN_PRESS, BACK_PRESS, ENTER_PRESS) / { lcd->SECRET_MENU_button(event_id); }
    {
        // Step 1: execute action `lcd->SECRET_MENU_button(event_id);`
        this->vars.lcd->SECRET_MENU_button(this->vars.event_id);
    } // end of behavior for SECRET_MENU
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state DATA
////////////////////////////////////////////////////////////////////////////////

void UiSm::DATA_enter()
{
    this->stateId = StateId::DATA;
    
    // DATA behavior
    // uml: (enter, ANY_KEY) / { timeout_ms = DATA_TIMEOUT_MS; }
    {
        // Step 1: execute action `timeout_ms = DATA_TIMEOUT_MS;`
        this->vars.timeout_ms = DATA_TIMEOUT_MS;
    } // end of behavior for DATA
}

void UiSm::DATA_exit()
{
    // DATA behavior
    // uml: exit / { timeout_ms = IDLE_TIMEOUT_MS; }
    {
        // Step 1: execute action `timeout_ms = IDLE_TIMEOUT_MS;`
        this->vars.timeout_ms = IDLE_TIMEOUT_MS;
    } // end of behavior for DATA
    
    this->stateId = StateId::MENU;
}

void UiSm::DATA_any_key()
{
    bool consume_event = false;
    
    // DATA behavior
    // uml: (enter, ANY_KEY) / { timeout_ms = DATA_TIMEOUT_MS; }
    {
        // Consume event `any_key`.
        consume_event = true;
        // Step 1: execute action `timeout_ms = DATA_TIMEOUT_MS;`
        this->vars.timeout_ms = DATA_TIMEOUT_MS;
    } // end of behavior for DATA
    
    // Check if event has been consumed before calling ancestor handler.
    if (!consume_event)
    {
        MENU_any_key();
    }
}

void UiSm::DATA_back_press()
{
    bool consume_event = false;
    
    // DATA behavior
    // uml: BACK_PRESS TransitionTo(MENU__DATA)
    {
        // Step 1: Exit states until we reach `MENU` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::MENU);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `MENU__DATA`.
        MENU__DATA_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for DATA
    
    // Check if event has been consumed before calling ancestor handler.
    if (!consume_event)
    {
        MENU_back_press();
    }
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state SENSOR
////////////////////////////////////////////////////////////////////////////////

void UiSm::SENSOR_enter()
{
    this->stateId = StateId::SENSOR;
    
    // SENSOR behavior
    // uml: enter / { lcd->SENSOR(); }
    {
        // Step 1: execute action `lcd->SENSOR();`
        this->vars.lcd->SENSOR();
    } // end of behavior for SENSOR
}

void UiSm::SENSOR_exit()
{
    this->stateId = StateId::DATA;
}

void UiSm::SENSOR_lcd_update()
{
    // SENSOR behavior
    // uml: LCD_UPDATE / { lcd->SENSOR_update(); }
    {
        // Step 1: execute action `lcd->SENSOR_update();`
        this->vars.lcd->SENSOR_update();
    } // end of behavior for SENSOR
    
    // No ancestor handles this event.
}

void UiSm::SENSOR_up_press()
{
    // SENSOR behavior
    // uml: UP_PRESS TransitionTo(UPTIME)
    {
        // Step 1: Exit states until we reach `DATA` state (Least Common Ancestor for transition).
        SENSOR_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `UPTIME`.
        UPTIME_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for SENSOR
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state UPTIME
////////////////////////////////////////////////////////////////////////////////

void UiSm::UPTIME_enter()
{
    this->stateId = StateId::UPTIME;
    
    // UPTIME behavior
    // uml: enter / { lcd->UPTIME(); }
    {
        // Step 1: execute action `lcd->UPTIME();`
        this->vars.lcd->UPTIME();
    } // end of behavior for UPTIME
}

void UiSm::UPTIME_exit()
{
    this->stateId = StateId::DATA;
}

void UiSm::UPTIME_down_press()
{
    // UPTIME behavior
    // uml: DOWN_PRESS TransitionTo(SENSOR)
    {
        // Step 1: Exit states until we reach `DATA` state (Least Common Ancestor for transition).
        UPTIME_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `SENSOR`.
        SENSOR_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for UPTIME
    
    // No ancestor handles this event.
}

void UiSm::UPTIME_lcd_update()
{
    // UPTIME behavior
    // uml: LCD_UPDATE / { lcd->UPTIME_update(); }
    {
        // Step 1: execute action `lcd->UPTIME_update();`
        this->vars.lcd->UPTIME_update();
    } // end of behavior for UPTIME
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state DISARM_SYSTEM
////////////////////////////////////////////////////////////////////////////////

void UiSm::DISARM_SYSTEM_enter()
{
    this->stateId = StateId::DISARM_SYSTEM;
    
    // DISARM_SYSTEM behavior
    // uml: enter / { lcd->DISARM_SYSTEM(); }
    {
        // Step 1: execute action `lcd->DISARM_SYSTEM();`
        this->vars.lcd->DISARM_SYSTEM();
    } // end of behavior for DISARM_SYSTEM
}

void UiSm::DISARM_SYSTEM_exit()
{
    this->stateId = StateId::MENU;
}

void UiSm::DISARM_SYSTEM_back_press()
{
    bool consume_event = false;
    
    // DISARM_SYSTEM behavior
    // uml: BACK_PRESS TransitionTo(MENU__DISARM_SYSTEM)
    {
        // Step 1: Exit states until we reach `MENU` state (Least Common Ancestor for transition).
        DISARM_SYSTEM_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `MENU__DISARM_SYSTEM`.
        MENU__DISARM_SYSTEM_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for DISARM_SYSTEM
    
    // Check if event has been consumed before calling ancestor handler.
    if (!consume_event)
    {
        MENU_back_press();
    }
}

void UiSm::DISARM_SYSTEM_enter_press()
{
    // DISARM_SYSTEM behavior
    // uml: ENTER_PRESS / { ctrl->disarm(); } TransitionTo(HOME)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::ROOT);
        
        // Step 2: Transition action: `ctrl->disarm();`.
        this->vars.ctrl->disarm();
        
        // Step 3: Enter/move towards transition target `HOME`.
        HOME_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for DISARM_SYSTEM
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state MENU__ARM_SYSTEM
////////////////////////////////////////////////////////////////////////////////

void UiSm::MENU__ARM_SYSTEM_enter()
{
    this->stateId = StateId::MENU__ARM_SYSTEM;
    
    // MENU__ARM_SYSTEM behavior
    // uml: enter / { lcd->MENU__ARM_SYSTEM(); }
    {
        // Step 1: execute action `lcd->MENU__ARM_SYSTEM();`
        this->vars.lcd->MENU__ARM_SYSTEM();
    } // end of behavior for MENU__ARM_SYSTEM
}

void UiSm::MENU__ARM_SYSTEM_exit()
{
    this->stateId = StateId::MENU;
}

void UiSm::MENU__ARM_SYSTEM_down_press()
{
    // MENU__ARM_SYSTEM behavior
    // uml: DOWN_PRESS TransitionTo(MENU__CONFIG)
    {
        // Step 1: Exit states until we reach `MENU` state (Least Common Ancestor for transition).
        MENU__ARM_SYSTEM_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `MENU__CONFIG`.
        MENU__CONFIG_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for MENU__ARM_SYSTEM
    
    // No ancestor handles this event.
}

void UiSm::MENU__ARM_SYSTEM_enter_press()
{
    // MENU__ARM_SYSTEM behavior
    // uml: ENTER_PRESS TransitionTo(ARM_SYSTEM)
    {
        // Step 1: Exit states until we reach `MENU` state (Least Common Ancestor for transition).
        MENU__ARM_SYSTEM_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `ARM_SYSTEM`.
        ARM_SYSTEM_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for MENU__ARM_SYSTEM
    
    // No ancestor handles this event.
}

void UiSm::MENU__ARM_SYSTEM_up_press()
{
    // MENU__ARM_SYSTEM behavior
    // uml: UP_PRESS TransitionTo(MENU__DISARM_SYSTEM)
    {
        // Step 1: Exit states until we reach `MENU` state (Least Common Ancestor for transition).
        MENU__ARM_SYSTEM_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `MENU__DISARM_SYSTEM`.
        MENU__DISARM_SYSTEM_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for MENU__ARM_SYSTEM
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state MENU__CONFIG
////////////////////////////////////////////////////////////////////////////////

void UiSm::MENU__CONFIG_enter()
{
    this->stateId = StateId::MENU__CONFIG;
    
    // MENU__CONFIG behavior
    // uml: enter / { lcd->MENU__CONFIG(); }
    {
        // Step 1: execute action `lcd->MENU__CONFIG();`
        this->vars.lcd->MENU__CONFIG();
    } // end of behavior for MENU__CONFIG
}

void UiSm::MENU__CONFIG_exit()
{
    this->stateId = StateId::MENU;
}

void UiSm::MENU__CONFIG_down_press()
{
    // MENU__CONFIG behavior
    // uml: DOWN_PRESS TransitionTo(MENU__DATA)
    {
        // Step 1: Exit states until we reach `MENU` state (Least Common Ancestor for transition).
        MENU__CONFIG_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `MENU__DATA`.
        MENU__DATA_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for MENU__CONFIG
    
    // No ancestor handles this event.
}

void UiSm::MENU__CONFIG_enter_press()
{
    // MENU__CONFIG behavior
    // uml: ENTER_PRESS TransitionTo(CONFIG)
    {
        // Step 1: Exit states until we reach `MENU` state (Least Common Ancestor for transition).
        MENU__CONFIG_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CONFIG`.
        CONFIG_enter();
        
        // CONFIG.<InitialState> behavior
        // uml: TransitionTo(CONFIG__CHANGE_CODE)
        {
            // Step 1: Exit states until we reach `CONFIG` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `CONFIG__CHANGE_CODE`.
            CONFIG__CHANGE_CODE_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for CONFIG.<InitialState>
    } // end of behavior for MENU__CONFIG
    
    // No ancestor handles this event.
}

void UiSm::MENU__CONFIG_up_press()
{
    // MENU__CONFIG behavior
    // uml: UP_PRESS TransitionTo(MENU__ARM_SYSTEM)
    {
        // Step 1: Exit states until we reach `MENU` state (Least Common Ancestor for transition).
        MENU__CONFIG_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `MENU__ARM_SYSTEM`.
        MENU__ARM_SYSTEM_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for MENU__CONFIG
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state MENU__DATA
////////////////////////////////////////////////////////////////////////////////

void UiSm::MENU__DATA_enter()
{
    this->stateId = StateId::MENU__DATA;
    
    // MENU__DATA behavior
    // uml: enter / { lcd->MENU__DATA(); }
    {
        // Step 1: execute action `lcd->MENU__DATA();`
        this->vars.lcd->MENU__DATA();
    } // end of behavior for MENU__DATA
}

void UiSm::MENU__DATA_exit()
{
    this->stateId = StateId::MENU;
}

void UiSm::MENU__DATA_enter_press()
{
    // MENU__DATA behavior
    // uml: ENTER_PRESS TransitionTo(DATA)
    {
        // Step 1: Exit states until we reach `MENU` state (Least Common Ancestor for transition).
        MENU__DATA_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `DATA`.
        DATA_enter();
        
        // DATA.<InitialState> behavior
        // uml: TransitionTo(UPTIME)
        {
            // Step 1: Exit states until we reach `DATA` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `UPTIME`.
            UPTIME_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for DATA.<InitialState>
    } // end of behavior for MENU__DATA
    
    // No ancestor handles this event.
}

void UiSm::MENU__DATA_up_press()
{
    // MENU__DATA behavior
    // uml: UP_PRESS TransitionTo(MENU__CONFIG)
    {
        // Step 1: Exit states until we reach `MENU` state (Least Common Ancestor for transition).
        MENU__DATA_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `MENU__CONFIG`.
        MENU__CONFIG_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for MENU__DATA
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state MENU__DISARM_SYSTEM
////////////////////////////////////////////////////////////////////////////////

void UiSm::MENU__DISARM_SYSTEM_enter()
{
    this->stateId = StateId::MENU__DISARM_SYSTEM;
    
    // MENU__DISARM_SYSTEM behavior
    // uml: enter / { lcd->MENU__DISARM_SYSTEM(); }
    {
        // Step 1: execute action `lcd->MENU__DISARM_SYSTEM();`
        this->vars.lcd->MENU__DISARM_SYSTEM();
    } // end of behavior for MENU__DISARM_SYSTEM
}

void UiSm::MENU__DISARM_SYSTEM_exit()
{
    this->stateId = StateId::MENU;
}

void UiSm::MENU__DISARM_SYSTEM_down_press()
{
    // MENU__DISARM_SYSTEM behavior
    // uml: DOWN_PRESS TransitionTo(MENU__ARM_SYSTEM)
    {
        // Step 1: Exit states until we reach `MENU` state (Least Common Ancestor for transition).
        MENU__DISARM_SYSTEM_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `MENU__ARM_SYSTEM`.
        MENU__ARM_SYSTEM_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for MENU__DISARM_SYSTEM
    
    // No ancestor handles this event.
}

void UiSm::MENU__DISARM_SYSTEM_enter_press()
{
    // MENU__DISARM_SYSTEM behavior
    // uml: ENTER_PRESS TransitionTo(DISARM_SYSTEM)
    {
        // Step 1: Exit states until we reach `MENU` state (Least Common Ancestor for transition).
        MENU__DISARM_SYSTEM_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `DISARM_SYSTEM`.
        DISARM_SYSTEM_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for MENU__DISARM_SYSTEM
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state PANIC
////////////////////////////////////////////////////////////////////////////////

void UiSm::PANIC_enter()
{
    this->stateId = StateId::PANIC;
    
    // PANIC behavior
    // uml: enter / { lcd->PANIC(); }
    {
        // Step 1: execute action `lcd->PANIC();`
        this->vars.lcd->PANIC();
    } // end of behavior for PANIC
    
    // PANIC behavior
    // uml: enter / { ctrl->panic(); }
    {
        // Step 1: execute action `ctrl->panic();`
        this->vars.ctrl->panic();
    } // end of behavior for PANIC
    
    // PANIC behavior
    // uml: enter / { timeout_ms = 3*1000; }
    {
        // Step 1: execute action `timeout_ms = 3*1000;`
        this->vars.timeout_ms = 3*1000;
    } // end of behavior for PANIC
}

void UiSm::PANIC_exit()
{
    this->stateId = StateId::ROOT;
}

void UiSm::PANIC_timeout()
{
    // PANIC behavior
    // uml: TIMEOUT TransitionTo(HOME)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        PANIC_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `HOME`.
        HOME_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for PANIC
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state SPLASH_SCREEN
////////////////////////////////////////////////////////////////////////////////

void UiSm::SPLASH_SCREEN_enter()
{
    this->stateId = StateId::SPLASH_SCREEN;
    
    // SPLASH_SCREEN behavior
    // uml: enter / { lcd->SPLASH_SCREEN(); }
    {
        // Step 1: execute action `lcd->SPLASH_SCREEN();`
        this->vars.lcd->SPLASH_SCREEN();
    } // end of behavior for SPLASH_SCREEN
    
    // SPLASH_SCREEN behavior
    // uml: enter / { timeout_ms = 3*1000; }
    {
        // Step 1: execute action `timeout_ms = 3*1000;`
        this->vars.timeout_ms = 3*1000;
    } // end of behavior for SPLASH_SCREEN
}

void UiSm::SPLASH_SCREEN_exit()
{
    this->stateId = StateId::ROOT;
}

void UiSm::SPLASH_SCREEN_timeout()
{
    // SPLASH_SCREEN behavior
    // uml: TIMEOUT TransitionTo(HOME)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        SPLASH_SCREEN_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `HOME`.
        HOME_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for SPLASH_SCREEN
    
    // No ancestor handles this event.
}

// Thread safe.
char const * UiSm::stateIdToString(StateId id)
{
    switch (id)
    {
        case StateId::ROOT: return "ROOT";
        case StateId::HOME: return "HOME";
        case StateId::MENU: return "MENU";
        case StateId::ARM_SYSTEM: return "ARM_SYSTEM";
        case StateId::CONFIG: return "CONFIG";
        case StateId::ALARM_DELAY: return "ALARM_DELAY";
        case StateId::ARMING_DELAY: return "ARMING_DELAY";
        case StateId::CHANGE_CODE: return "CHANGE_CODE";
        case StateId::CONFIG__ALARM_DELAY: return "CONFIG__ALARM_DELAY";
        case StateId::CONFIG__ARMING_DELAY: return "CONFIG__ARMING_DELAY";
        case StateId::CONFIG__CHANGE_CODE: return "CONFIG__CHANGE_CODE";
        case StateId::SECRET_MENU: return "SECRET_MENU";
        case StateId::DATA: return "DATA";
        case StateId::SENSOR: return "SENSOR";
        case StateId::UPTIME: return "UPTIME";
        case StateId::DISARM_SYSTEM: return "DISARM_SYSTEM";
        case StateId::MENU__ARM_SYSTEM: return "MENU__ARM_SYSTEM";
        case StateId::MENU__CONFIG: return "MENU__CONFIG";
        case StateId::MENU__DATA: return "MENU__DATA";
        case StateId::MENU__DISARM_SYSTEM: return "MENU__DISARM_SYSTEM";
        case StateId::PANIC: return "PANIC";
        case StateId::SPLASH_SCREEN: return "SPLASH_SCREEN";
        default: return "?";
    }
}

// Thread safe.
char const * UiSm::eventIdToString(EventId id)
{
    switch (id)
    {
        case EventId::ANY_KEY: return "ANY_KEY";
        case EventId::BACK_HELD: return "BACK_HELD";
        case EventId::BACK_PRESS: return "BACK_PRESS";
        case EventId::DOWN_PRESS: return "DOWN_PRESS";
        case EventId::ENTER_PRESS: return "ENTER_PRESS";
        case EventId::LCD_UPDATE: return "LCD_UPDATE";
        case EventId::PANIC_BUTTON: return "PANIC_BUTTON";
        case EventId::REFRESH: return "REFRESH";
        case EventId::TIMEOUT: return "TIMEOUT";
        case EventId::UP_DOWN_HELD: return "UP_DOWN_HELD";
        case EventId::UP_PRESS: return "UP_PRESS";
        default: return "?";
    }
}
