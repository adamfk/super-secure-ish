// Autogenerated with StateSmith 0.18.2+6062baabb038910ff3841c3cd5938115c0ed0a03.
// Algorithm: Balanced2. See https://github.com/StateSmith/StateSmith/wiki/Algorithms

#include "UiSm.hpp"
#include <stdbool.h> // required for `consume_event` flag
#include <string.h> // for memset
#define IDLE_TIMEOUT_MS (10 * 1000) // this works for C99 as well as C++11



// Starts the state machine. Must be called before dispatching events. Not thread safe.
void UiSm::start()
{
    ROOT_enter();
    // ROOT behavior
    // uml: TransitionTo(ROOT.<InitialState>)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `ROOT.<InitialState>`.
        // ROOT.<InitialState> is a pseudo state and cannot have an `enter` trigger.
        
        // ROOT.<InitialState> behavior
        // uml: TransitionTo(SPLASH_SCREEN)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `SPLASH_SCREEN`.
            SPLASH_SCREEN_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for ROOT.<InitialState>
    } // end of behavior for ROOT
}

// Dispatches an event to the state machine. Not thread safe.
// Note! This function assumes that the `eventId` parameter is valid.
void UiSm::dispatchEvent(EventId eventId)
{
    switch (this->stateId)
    {
        // STATE: UiSm
        case StateId::ROOT:
            // No events handled by this state (or its ancestors).
            break;
        
        // STATE: HOME
        case StateId::HOME:
            switch (eventId)
            {
                case EventId::ENTER_PRESS: HOME_enter_press(); break;
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: MENU
        case StateId::MENU:
            switch (eventId)
            {
                case EventId::ANY_KEY: MENU_any_key(); break;
                case EventId::BACK_PRESS: MENU_back_press(); break;
                case EventId::TIMEOUT: MENU_timeout(); break;
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: ARM_SYSTEM
        case StateId::ARM_SYSTEM:
            switch (eventId)
            {
                case EventId::ENTER_PRESS: ARM_SYSTEM_enter_press(); break;
                case EventId::UP_PRESS: ARM_SYSTEM_up_press(); break;
                case EventId::TIMEOUT: MENU_timeout(); break; // First ancestor handler for this event
                case EventId::ANY_KEY: MENU_any_key(); break; // First ancestor handler for this event
                case EventId::BACK_PRESS: MENU_back_press(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: DISARM_SYSTEM
        case StateId::DISARM_SYSTEM:
            switch (eventId)
            {
                case EventId::ENTER_PRESS: DISARM_SYSTEM_enter_press(); break;
                case EventId::DOWN_PRESS: DISARM_SYSTEM_down_press(); break;
                case EventId::TIMEOUT: MENU_timeout(); break; // First ancestor handler for this event
                case EventId::ANY_KEY: MENU_any_key(); break; // First ancestor handler for this event
                case EventId::BACK_PRESS: MENU_back_press(); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: SPLASH_SCREEN
        case StateId::SPLASH_SCREEN:
            switch (eventId)
            {
                case EventId::TIMEOUT: SPLASH_SCREEN_timeout(); break;
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
    }
    
}

// This function is used when StateSmith doesn't know what the active leaf state is at
// compile time due to sub states or when multiple states need to be exited.
void UiSm::exitUpToStateHandler(StateId desiredState)
{
    while (this->stateId != desiredState)
    {
        switch (this->stateId)
        {
            case StateId::HOME: HOME_exit(); break;
            
            case StateId::MENU: MENU_exit(); break;
            
            case StateId::ARM_SYSTEM: ARM_SYSTEM_exit(); break;
            
            case StateId::DISARM_SYSTEM: DISARM_SYSTEM_exit(); break;
            
            case StateId::SPLASH_SCREEN: SPLASH_SCREEN_exit(); break;
            
            default: return;  // Just to be safe. Prevents infinite loop if state ID memory is somehow corrupted.
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state ROOT
////////////////////////////////////////////////////////////////////////////////

void UiSm::ROOT_enter()
{
    this->stateId = StateId::ROOT;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state HOME
////////////////////////////////////////////////////////////////////////////////

void UiSm::HOME_enter()
{
    this->stateId = StateId::HOME;
    
    // HOME behavior
    // uml: enter / { lcd->HOME(); }
    {
        // Step 1: execute action `lcd->HOME();`
        this->vars.lcd->HOME();
    } // end of behavior for HOME
}

void UiSm::HOME_exit()
{
    this->stateId = StateId::ROOT;
}

void UiSm::HOME_enter_press()
{
    // HOME behavior
    // uml: ENTER_PRESS TransitionTo(MENU)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        HOME_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `MENU`.
        MENU_enter();
        
        // MENU.<InitialState> behavior
        // uml: TransitionTo(DISARM_SYSTEM)
        {
            // Step 1: Exit states until we reach `MENU` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `DISARM_SYSTEM`.
            DISARM_SYSTEM_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for MENU.<InitialState>
    } // end of behavior for HOME
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state MENU
////////////////////////////////////////////////////////////////////////////////

void UiSm::MENU_enter()
{
    this->stateId = StateId::MENU;
    
    // MENU behavior
    // uml: (enter, ANY_KEY) / { timeout_ms = IDLE_TIMEOUT_MS; }
    {
        // Step 1: execute action `timeout_ms = IDLE_TIMEOUT_MS;`
        this->vars.timeout_ms = IDLE_TIMEOUT_MS;
    } // end of behavior for MENU
}

void UiSm::MENU_exit()
{
    this->stateId = StateId::ROOT;
}

void UiSm::MENU_any_key()
{
    // MENU behavior
    // uml: (enter, ANY_KEY) / { timeout_ms = IDLE_TIMEOUT_MS; }
    {
        // Step 1: execute action `timeout_ms = IDLE_TIMEOUT_MS;`
        this->vars.timeout_ms = IDLE_TIMEOUT_MS;
    } // end of behavior for MENU
    
    // No ancestor handles this event.
}

void UiSm::MENU_back_press()
{
    // MENU behavior
    // uml: (BACK_PRESS, TIMEOUT) TransitionTo(HOME)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::ROOT);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `HOME`.
        HOME_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for MENU
    
    // No ancestor handles this event.
}

void UiSm::MENU_timeout()
{
    // MENU behavior
    // uml: (BACK_PRESS, TIMEOUT) TransitionTo(HOME)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exitUpToStateHandler(StateId::ROOT);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `HOME`.
        HOME_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for MENU
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state ARM_SYSTEM
////////////////////////////////////////////////////////////////////////////////

void UiSm::ARM_SYSTEM_enter()
{
    this->stateId = StateId::ARM_SYSTEM;
    
    // ARM_SYSTEM behavior
    // uml: enter / { lcd->ARM_SYSTEM(); }
    {
        // Step 1: execute action `lcd->ARM_SYSTEM();`
        this->vars.lcd->ARM_SYSTEM();
    } // end of behavior for ARM_SYSTEM
}

void UiSm::ARM_SYSTEM_exit()
{
    this->stateId = StateId::MENU;
}

void UiSm::ARM_SYSTEM_enter_press()
{
    // ARM_SYSTEM behavior
    // uml: ENTER_PRESS / { ctrl->arm(); }
    {
        // Step 1: execute action `ctrl->arm();`
        this->vars.ctrl->arm();
    } // end of behavior for ARM_SYSTEM
    
    // No ancestor handles this event.
}

void UiSm::ARM_SYSTEM_up_press()
{
    // ARM_SYSTEM behavior
    // uml: UP_PRESS TransitionTo(DISARM_SYSTEM)
    {
        // Step 1: Exit states until we reach `MENU` state (Least Common Ancestor for transition).
        ARM_SYSTEM_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `DISARM_SYSTEM`.
        DISARM_SYSTEM_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for ARM_SYSTEM
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state DISARM_SYSTEM
////////////////////////////////////////////////////////////////////////////////

void UiSm::DISARM_SYSTEM_enter()
{
    this->stateId = StateId::DISARM_SYSTEM;
    
    // DISARM_SYSTEM behavior
    // uml: enter / { lcd->DISARM_SYSTEM(); }
    {
        // Step 1: execute action `lcd->DISARM_SYSTEM();`
        this->vars.lcd->DISARM_SYSTEM();
    } // end of behavior for DISARM_SYSTEM
}

void UiSm::DISARM_SYSTEM_exit()
{
    this->stateId = StateId::MENU;
}

void UiSm::DISARM_SYSTEM_down_press()
{
    // DISARM_SYSTEM behavior
    // uml: DOWN_PRESS TransitionTo(ARM_SYSTEM)
    {
        // Step 1: Exit states until we reach `MENU` state (Least Common Ancestor for transition).
        DISARM_SYSTEM_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `ARM_SYSTEM`.
        ARM_SYSTEM_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for DISARM_SYSTEM
    
    // No ancestor handles this event.
}

void UiSm::DISARM_SYSTEM_enter_press()
{
    // DISARM_SYSTEM behavior
    // uml: ENTER_PRESS / { ctrl->disarm(); }
    {
        // Step 1: execute action `ctrl->disarm();`
        this->vars.ctrl->disarm();
    } // end of behavior for DISARM_SYSTEM
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state SPLASH_SCREEN
////////////////////////////////////////////////////////////////////////////////

void UiSm::SPLASH_SCREEN_enter()
{
    this->stateId = StateId::SPLASH_SCREEN;
    
    // SPLASH_SCREEN behavior
    // uml: enter / { lcd->SPLASH_SCREEN(); }
    {
        // Step 1: execute action `lcd->SPLASH_SCREEN();`
        this->vars.lcd->SPLASH_SCREEN();
    } // end of behavior for SPLASH_SCREEN
    
    // SPLASH_SCREEN behavior
    // uml: enter / { timeout_ms = 3*1000; }
    {
        // Step 1: execute action `timeout_ms = 3*1000;`
        this->vars.timeout_ms = 3*1000;
    } // end of behavior for SPLASH_SCREEN
}

void UiSm::SPLASH_SCREEN_exit()
{
    this->stateId = StateId::ROOT;
}

void UiSm::SPLASH_SCREEN_timeout()
{
    // SPLASH_SCREEN behavior
    // uml: TIMEOUT TransitionTo(HOME)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        SPLASH_SCREEN_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `HOME`.
        HOME_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for SPLASH_SCREEN
    
    // No ancestor handles this event.
}

// Thread safe.
char const * UiSm::stateIdToString(StateId id)
{
    switch (id)
    {
        case StateId::ROOT: return "ROOT";
        case StateId::HOME: return "HOME";
        case StateId::MENU: return "MENU";
        case StateId::ARM_SYSTEM: return "ARM_SYSTEM";
        case StateId::DISARM_SYSTEM: return "DISARM_SYSTEM";
        case StateId::SPLASH_SCREEN: return "SPLASH_SCREEN";
        default: return "?";
    }
}

// Thread safe.
char const * UiSm::eventIdToString(EventId id)
{
    switch (id)
    {
        case EventId::ANY_KEY: return "ANY_KEY";
        case EventId::BACK_PRESS: return "BACK_PRESS";
        case EventId::DOWN_PRESS: return "DOWN_PRESS";
        case EventId::ENTER_PRESS: return "ENTER_PRESS";
        case EventId::TIMEOUT: return "TIMEOUT";
        case EventId::UP_PRESS: return "UP_PRESS";
        default: return "?";
    }
}
