// Autogenerated with StateSmith 0.18.2+6062baabb038910ff3841c3cd5938115c0ed0a03.
// Algorithm: Balanced2. See https://github.com/StateSmith/StateSmith/wiki/Algorithms

#include "ButtonSm.h"
#include <stdbool.h> // required for `consume_event` flag
#include <string.h> // for memset

// This function is used when StateSmith doesn't know what the active leaf state is at
// compile time due to sub states or when multiple states need to be exited.
static void exit_up_to_state_handler(ButtonSm* sm, ButtonSm_StateId desired_state);

static void ROOT_enter(ButtonSm* sm);

static void PRESSED_DEBOUNCE_enter(ButtonSm* sm);

static void PRESSED_DEBOUNCE_exit(ButtonSm* sm);

static void PRESSED_DEBOUNCE_do(ButtonSm* sm);

static void PRESSED_STABLE_enter(ButtonSm* sm);

static void PRESSED_STABLE_exit(ButtonSm* sm);

static void PRESSED_STABLE_do(ButtonSm* sm);

static void CONFIRM_LONG_enter(ButtonSm* sm);

static void CONFIRM_LONG_exit(ButtonSm* sm);

static void CONFIRM_LONG_do(ButtonSm* sm);

static void PRESSED_LONG_enter(ButtonSm* sm);

static void PRESSED_LONG_exit(ButtonSm* sm);

static void RELEASED_DEBOUNCE_enter(ButtonSm* sm);

static void RELEASED_DEBOUNCE_exit(ButtonSm* sm);

static void RELEASED_DEBOUNCE_do(ButtonSm* sm);

static void RELEASED_STABLE_enter(ButtonSm* sm);

static void RELEASED_STABLE_exit(ButtonSm* sm);

static void RELEASED_STABLE_do(ButtonSm* sm);


// State machine constructor. Must be called before start or dispatch event functions. Not thread safe.
void ButtonSm_ctor(ButtonSm* sm)
{
    memset(sm, 0, sizeof(*sm));
}

// Starts the state machine. Must be called before dispatching events. Not thread safe.
void ButtonSm_start(ButtonSm* sm)
{
    ROOT_enter(sm);
    // ROOT behavior
    // uml: TransitionTo(ROOT.<InitialState>)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `ROOT.<InitialState>`.
        // ROOT.<InitialState> is a pseudo state and cannot have an `enter` trigger.
        
        // ROOT.<InitialState> behavior
        // uml: TransitionTo(RELEASED_DEBOUNCE)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `RELEASED_DEBOUNCE`.
            RELEASED_DEBOUNCE_enter(sm);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for ROOT.<InitialState>
    } // end of behavior for ROOT
}

// Dispatches an event to the state machine. Not thread safe.
// Note! This function assumes that the `event_id` parameter is valid.
void ButtonSm_dispatch_event(ButtonSm* sm, ButtonSm_EventId event_id)
{
    // This state machine design only has a single event type so we can safely assume
    // that the dispatched event is `do` without checking the `event_id` parameter.
    (void)event_id; // This line prevents an 'unused variable' compiler warning
    
    switch (sm->state_id)
    {
        // STATE: ButtonSm
        case ButtonSm_StateId_ROOT:
            // state and ancestors have no handler for `do` event.
            break;
        
        // STATE: PRESSED_DEBOUNCE
        case ButtonSm_StateId_PRESSED_DEBOUNCE:
            PRESSED_DEBOUNCE_do(sm); 
            break;
        
        // STATE: PRESSED_STABLE
        case ButtonSm_StateId_PRESSED_STABLE:
            PRESSED_STABLE_do(sm); 
            break;
        
        // STATE: CONFIRM_LONG
        case ButtonSm_StateId_CONFIRM_LONG:
            CONFIRM_LONG_do(sm); 
            break;
        
        // STATE: PRESSED_LONG
        case ButtonSm_StateId_PRESSED_LONG:
            PRESSED_STABLE_do(sm);  // First ancestor handler for this event

            break;
        
        // STATE: RELEASED_DEBOUNCE
        case ButtonSm_StateId_RELEASED_DEBOUNCE:
            RELEASED_DEBOUNCE_do(sm); 
            break;
        
        // STATE: RELEASED_STABLE
        case ButtonSm_StateId_RELEASED_STABLE:
            RELEASED_STABLE_do(sm); 
            break;
    }
    
}

// This function is used when StateSmith doesn't know what the active leaf state is at
// compile time due to sub states or when multiple states need to be exited.
static void exit_up_to_state_handler(ButtonSm* sm, ButtonSm_StateId desired_state)
{
    while (sm->state_id != desired_state)
    {
        switch (sm->state_id)
        {
            case ButtonSm_StateId_PRESSED_DEBOUNCE: PRESSED_DEBOUNCE_exit(sm); break;
            
            case ButtonSm_StateId_PRESSED_STABLE: PRESSED_STABLE_exit(sm); break;
            
            case ButtonSm_StateId_CONFIRM_LONG: CONFIRM_LONG_exit(sm); break;
            
            case ButtonSm_StateId_PRESSED_LONG: PRESSED_LONG_exit(sm); break;
            
            case ButtonSm_StateId_RELEASED_DEBOUNCE: RELEASED_DEBOUNCE_exit(sm); break;
            
            case ButtonSm_StateId_RELEASED_STABLE: RELEASED_STABLE_exit(sm); break;
            
            default: return;  // Just to be safe. Prevents infinite loop if state ID memory is somehow corrupted.
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state ROOT
////////////////////////////////////////////////////////////////////////////////

static void ROOT_enter(ButtonSm* sm)
{
    sm->state_id = ButtonSm_StateId_ROOT;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state PRESSED_DEBOUNCE
////////////////////////////////////////////////////////////////////////////////

static void PRESSED_DEBOUNCE_enter(ButtonSm* sm)
{
    sm->state_id = ButtonSm_StateId_PRESSED_DEBOUNCE;
    
    // PRESSED_DEBOUNCE behavior
    // uml: enter / { timer_ms = 0; }
    {
        // Step 1: execute action `timer_ms = 0;`
        sm->vars.timer_ms = 0;
    } // end of behavior for PRESSED_DEBOUNCE
    
    // PRESSED_DEBOUNCE behavior
    // uml: enter / { press_status = true; }
    {
        // Step 1: execute action `press_status = true;`
        sm->vars.press_status = true;
    } // end of behavior for PRESSED_DEBOUNCE
    
    // PRESSED_DEBOUNCE behavior
    // uml: enter / { press_event = true; }
    {
        // Step 1: execute action `press_event = true;`
        sm->vars.press_event = true;
    } // end of behavior for PRESSED_DEBOUNCE
}

static void PRESSED_DEBOUNCE_exit(ButtonSm* sm)
{
    sm->state_id = ButtonSm_StateId_ROOT;
}

static void PRESSED_DEBOUNCE_do(ButtonSm* sm)
{
    // PRESSED_DEBOUNCE behavior
    // uml: do [timer_ms > 50] TransitionTo(PRESSED_STABLE)
    if (sm->vars.timer_ms > 50)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        PRESSED_DEBOUNCE_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `PRESSED_STABLE`.
        PRESSED_STABLE_enter(sm);
        
        // PRESSED_STABLE.<InitialState> behavior
        // uml: TransitionTo(CONFIRM_LONG)
        {
            // Step 1: Exit states until we reach `PRESSED_STABLE` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `CONFIRM_LONG`.
            CONFIRM_LONG_enter(sm);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for PRESSED_STABLE.<InitialState>
    } // end of behavior for PRESSED_DEBOUNCE
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state PRESSED_STABLE
////////////////////////////////////////////////////////////////////////////////

static void PRESSED_STABLE_enter(ButtonSm* sm)
{
    sm->state_id = ButtonSm_StateId_PRESSED_STABLE;
}

static void PRESSED_STABLE_exit(ButtonSm* sm)
{
    sm->state_id = ButtonSm_StateId_ROOT;
}

static void PRESSED_STABLE_do(ButtonSm* sm)
{
    // PRESSED_STABLE behavior
    // uml: do [! input_active] / { release_event = true; } TransitionTo(RELEASED_DEBOUNCE)
    if (! sm->vars.input_active)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, ButtonSm_StateId_ROOT);
        
        // Step 2: Transition action: `release_event = true;`.
        sm->vars.release_event = true;
        
        // Step 3: Enter/move towards transition target `RELEASED_DEBOUNCE`.
        RELEASED_DEBOUNCE_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for PRESSED_STABLE
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state CONFIRM_LONG
////////////////////////////////////////////////////////////////////////////////

static void CONFIRM_LONG_enter(ButtonSm* sm)
{
    sm->state_id = ButtonSm_StateId_CONFIRM_LONG;
}

static void CONFIRM_LONG_exit(ButtonSm* sm)
{
    sm->state_id = ButtonSm_StateId_PRESSED_STABLE;
}

static void CONFIRM_LONG_do(ButtonSm* sm)
{
    bool consume_event = false;
    
    // CONFIRM_LONG behavior
    // uml: do [timer_ms > 1000] TransitionTo(PRESSED_LONG)
    if (sm->vars.timer_ms > 1000)
    {
        // Step 1: Exit states until we reach `PRESSED_STABLE` state (Least Common Ancestor for transition).
        CONFIRM_LONG_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `PRESSED_LONG`.
        PRESSED_LONG_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for CONFIRM_LONG
    
    // Check if event has been consumed before calling ancestor handler.
    if (!consume_event)
    {
        PRESSED_STABLE_do(sm);
    }
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state PRESSED_LONG
////////////////////////////////////////////////////////////////////////////////

static void PRESSED_LONG_enter(ButtonSm* sm)
{
    sm->state_id = ButtonSm_StateId_PRESSED_LONG;
    
    // PRESSED_LONG behavior
    // uml: enter / { long_event = true; }
    {
        // Step 1: execute action `long_event = true;`
        sm->vars.long_event = true;
    } // end of behavior for PRESSED_LONG
    
    // PRESSED_LONG behavior
    // uml: enter / { long_status = true; }
    {
        // Step 1: execute action `long_status = true;`
        sm->vars.long_status = true;
    } // end of behavior for PRESSED_LONG
}

static void PRESSED_LONG_exit(ButtonSm* sm)
{
    // PRESSED_LONG behavior
    // uml: exit / { long_status = false; }
    {
        // Step 1: execute action `long_status = false;`
        sm->vars.long_status = false;
    } // end of behavior for PRESSED_LONG
    
    sm->state_id = ButtonSm_StateId_PRESSED_STABLE;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state RELEASED_DEBOUNCE
////////////////////////////////////////////////////////////////////////////////

static void RELEASED_DEBOUNCE_enter(ButtonSm* sm)
{
    sm->state_id = ButtonSm_StateId_RELEASED_DEBOUNCE;
    
    // RELEASED_DEBOUNCE behavior
    // uml: enter / { timer_ms = 0; }
    {
        // Step 1: execute action `timer_ms = 0;`
        sm->vars.timer_ms = 0;
    } // end of behavior for RELEASED_DEBOUNCE
    
    // RELEASED_DEBOUNCE behavior
    // uml: enter / { press_status = false; }
    {
        // Step 1: execute action `press_status = false;`
        sm->vars.press_status = false;
    } // end of behavior for RELEASED_DEBOUNCE
}

static void RELEASED_DEBOUNCE_exit(ButtonSm* sm)
{
    sm->state_id = ButtonSm_StateId_ROOT;
}

static void RELEASED_DEBOUNCE_do(ButtonSm* sm)
{
    // RELEASED_DEBOUNCE behavior
    // uml: do [timer_ms > 50] TransitionTo(RELEASED_STABLE)
    if (sm->vars.timer_ms > 50)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        RELEASED_DEBOUNCE_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `RELEASED_STABLE`.
        RELEASED_STABLE_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for RELEASED_DEBOUNCE
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state RELEASED_STABLE
////////////////////////////////////////////////////////////////////////////////

static void RELEASED_STABLE_enter(ButtonSm* sm)
{
    sm->state_id = ButtonSm_StateId_RELEASED_STABLE;
}

static void RELEASED_STABLE_exit(ButtonSm* sm)
{
    sm->state_id = ButtonSm_StateId_ROOT;
}

static void RELEASED_STABLE_do(ButtonSm* sm)
{
    // RELEASED_STABLE behavior
    // uml: do [input_active] TransitionTo(PRESSED_DEBOUNCE)
    if (sm->vars.input_active)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        RELEASED_STABLE_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `PRESSED_DEBOUNCE`.
        PRESSED_DEBOUNCE_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for RELEASED_STABLE
    
    // No ancestor handles this event.
}

// Thread safe.
char const * ButtonSm_state_id_to_string(ButtonSm_StateId id)
{
    switch (id)
    {
        case ButtonSm_StateId_ROOT: return "ROOT";
        case ButtonSm_StateId_PRESSED_DEBOUNCE: return "PRESSED_DEBOUNCE";
        case ButtonSm_StateId_PRESSED_STABLE: return "PRESSED_STABLE";
        case ButtonSm_StateId_CONFIRM_LONG: return "CONFIRM_LONG";
        case ButtonSm_StateId_PRESSED_LONG: return "PRESSED_LONG";
        case ButtonSm_StateId_RELEASED_DEBOUNCE: return "RELEASED_DEBOUNCE";
        case ButtonSm_StateId_RELEASED_STABLE: return "RELEASED_STABLE";
        default: return "?";
    }
}

// Thread safe.
char const * ButtonSm_event_id_to_string(ButtonSm_EventId id)
{
    switch (id)
    {
        case ButtonSm_EventId_DO: return "DO";
        default: return "?";
    }
}
