// Autogenerated with StateSmith 0.18.2+6062baabb038910ff3841c3cd5938115c0ed0a03.
// Algorithm: Balanced2. See https://github.com/StateSmith/StateSmith/wiki/Algorithms

#include "ControllerSm.hpp"
#include <stdbool.h> // required for `consume_event` flag
#include <string.h> // for memset


// Starts the state machine. Must be called before dispatching events. Not thread safe.
void ControllerSm::start()
{
    ROOT_enter();
    // ROOT behavior
    // uml: TransitionTo(ROOT.<InitialState>)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `ROOT.<InitialState>`.
        // ROOT.<InitialState> is a pseudo state and cannot have an `enter` trigger.
        
        // ROOT.<InitialState> behavior
        // uml: TransitionTo(DISARMED)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `DISARMED`.
            DISARMED_enter();
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for ROOT.<InitialState>
    } // end of behavior for ROOT
}

// Dispatches an event to the state machine. Not thread safe.
// Note! This function assumes that the `eventId` parameter is valid.
void ControllerSm::dispatchEvent(EventId eventId)
{
    switch (this->stateId)
    {
        // STATE: ControllerSm
        case StateId::ROOT:
            // No events handled by this state (or its ancestors).
            break;
        
        // STATE: ALARM_ACTIVE
        case StateId::ALARM_ACTIVE:
            switch (eventId)
            {
                case EventId::DISARM: ALARM_ACTIVE_disarm(); break;
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: ALARM_COUNTDOWN
        case StateId::ALARM_COUNTDOWN:
            switch (eventId)
            {
                case EventId::DO: ALARM_COUNTDOWN_do(); break;
                case EventId::DISARM: ALARM_COUNTDOWN_disarm(); break;
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: ARMED
        case StateId::ARMED:
            switch (eventId)
            {
                case EventId::DO: ARMED_do(); break;
                case EventId::DISARM: ARMED_disarm(); break;
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: ARMING
        case StateId::ARMING:
            switch (eventId)
            {
                case EventId::DO: ARMING_do(); break;
                case EventId::DISARM: ARMING_disarm(); break;
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: DISARMED
        case StateId::DISARMED:
            switch (eventId)
            {
                case EventId::ARM: DISARMED_arm(); break;
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
    }
    
}

// This function is used when StateSmith doesn't know what the active leaf state is at
// compile time due to sub states or when multiple states need to be exited.
void ControllerSm::exitUpToStateHandler(StateId desiredState)
{
    while (this->stateId != desiredState)
    {
        switch (this->stateId)
        {
            case StateId::ALARM_ACTIVE: ALARM_ACTIVE_exit(); break;
            
            case StateId::ALARM_COUNTDOWN: ALARM_COUNTDOWN_exit(); break;
            
            case StateId::ARMED: ARMED_exit(); break;
            
            case StateId::ARMING: ARMING_exit(); break;
            
            case StateId::DISARMED: DISARMED_exit(); break;
            
            default: return;  // Just to be safe. Prevents infinite loop if state ID memory is somehow corrupted.
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state ROOT
////////////////////////////////////////////////////////////////////////////////

void ControllerSm::ROOT_enter()
{
    this->stateId = StateId::ROOT;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state ALARM_ACTIVE
////////////////////////////////////////////////////////////////////////////////

void ControllerSm::ALARM_ACTIVE_enter()
{
    this->stateId = StateId::ALARM_ACTIVE;
    
    // ALARM_ACTIVE behavior
    // uml: enter / { set_red_led(true); }
    {
        // Step 1: execute action `set_red_led(true);`
        set_red_led(true);
    } // end of behavior for ALARM_ACTIVE
    
    // ALARM_ACTIVE behavior
    // uml: enter / { notify_alarm(); }
    {
        // Step 1: execute action `notify_alarm();`
        notify_alarm();
    } // end of behavior for ALARM_ACTIVE
}

void ControllerSm::ALARM_ACTIVE_exit()
{
    // ALARM_ACTIVE behavior
    // uml: exit / { set_red_led(false); }
    {
        // Step 1: execute action `set_red_led(false);`
        set_red_led(false);
    } // end of behavior for ALARM_ACTIVE
    
    this->stateId = StateId::ROOT;
}

void ControllerSm::ALARM_ACTIVE_disarm()
{
    // ALARM_ACTIVE behavior
    // uml: DISARM TransitionTo(DISARMED)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        ALARM_ACTIVE_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `DISARMED`.
        DISARMED_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for ALARM_ACTIVE
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state ALARM_COUNTDOWN
////////////////////////////////////////////////////////////////////////////////

void ControllerSm::ALARM_COUNTDOWN_enter()
{
    this->stateId = StateId::ALARM_COUNTDOWN;
    
    // ALARM_COUNTDOWN behavior
    // uml: enter / { init_alarm_countdown(); }
    {
        // Step 1: execute action `init_alarm_countdown();`
        init_alarm_countdown();
    } // end of behavior for ALARM_COUNTDOWN
}

void ControllerSm::ALARM_COUNTDOWN_exit()
{
    // ALARM_COUNTDOWN behavior
    // uml: exit / { clear_countdown(); }
    {
        // Step 1: execute action `clear_countdown();`
        clear_countdown();
    } // end of behavior for ALARM_COUNTDOWN
    
    this->stateId = StateId::ROOT;
}

void ControllerSm::ALARM_COUNTDOWN_disarm()
{
    // ALARM_COUNTDOWN behavior
    // uml: DISARM TransitionTo(DISARMED)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        ALARM_COUNTDOWN_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `DISARMED`.
        DISARMED_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for ALARM_COUNTDOWN
    
    // No ancestor handles this event.
}

void ControllerSm::ALARM_COUNTDOWN_do()
{
    // ALARM_COUNTDOWN behavior
    // uml: do [is_countdown_complete()] TransitionTo(ALARM_ACTIVE)
    if (is_countdown_complete())
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        ALARM_COUNTDOWN_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `ALARM_ACTIVE`.
        ALARM_ACTIVE_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for ALARM_COUNTDOWN
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state ARMED
////////////////////////////////////////////////////////////////////////////////

void ControllerSm::ARMED_enter()
{
    this->stateId = StateId::ARMED;
    
    // ARMED behavior
    // uml: enter / { notify_armed(); }
    {
        // Step 1: execute action `notify_armed();`
        notify_armed();
    } // end of behavior for ARMED
}

void ControllerSm::ARMED_exit()
{
    this->stateId = StateId::ROOT;
}

void ControllerSm::ARMED_disarm()
{
    // ARMED behavior
    // uml: DISARM TransitionTo(DISARMED)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        ARMED_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `DISARMED`.
        DISARMED_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for ARMED
    
    // No ancestor handles this event.
}

void ControllerSm::ARMED_do()
{
    // ARMED behavior
    // uml: do [is_motion_detected()] TransitionTo(ALARM_COUNTDOWN)
    if (is_motion_detected())
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        ARMED_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `ALARM_COUNTDOWN`.
        ALARM_COUNTDOWN_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for ARMED
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state ARMING
////////////////////////////////////////////////////////////////////////////////

void ControllerSm::ARMING_enter()
{
    this->stateId = StateId::ARMING;
    
    // ARMING behavior
    // uml: enter / { init_arming_countdown(); }
    {
        // Step 1: execute action `init_arming_countdown();`
        init_arming_countdown();
    } // end of behavior for ARMING
}

void ControllerSm::ARMING_exit()
{
    // ARMING behavior
    // uml: exit / { clear_countdown(); }
    {
        // Step 1: execute action `clear_countdown();`
        clear_countdown();
    } // end of behavior for ARMING
    
    this->stateId = StateId::ROOT;
}

void ControllerSm::ARMING_disarm()
{
    // ARMING behavior
    // uml: DISARM TransitionTo(DISARMED)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        ARMING_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `DISARMED`.
        DISARMED_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for ARMING
    
    // No ancestor handles this event.
}

void ControllerSm::ARMING_do()
{
    // ARMING behavior
    // uml: do [is_countdown_complete()] TransitionTo(ARMED)
    if (is_countdown_complete())
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        ARMING_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `ARMED`.
        ARMED_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for ARMING
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state DISARMED
////////////////////////////////////////////////////////////////////////////////

void ControllerSm::DISARMED_enter()
{
    this->stateId = StateId::DISARMED;
    
    // DISARMED behavior
    // uml: enter / { notify_disarmed(); }
    {
        // Step 1: execute action `notify_disarmed();`
        notify_disarmed();
    } // end of behavior for DISARMED
}

void ControllerSm::DISARMED_exit()
{
    this->stateId = StateId::ROOT;
}

void ControllerSm::DISARMED_arm()
{
    // DISARMED behavior
    // uml: ARM TransitionTo(ARMING)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        DISARMED_exit();
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `ARMING`.
        ARMING_enter();
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for DISARMED
    
    // No ancestor handles this event.
}

// Thread safe.
char const * ControllerSm::stateIdToString(StateId id)
{
    switch (id)
    {
        case StateId::ROOT: return "ROOT";
        case StateId::ALARM_ACTIVE: return "ALARM_ACTIVE";
        case StateId::ALARM_COUNTDOWN: return "ALARM_COUNTDOWN";
        case StateId::ARMED: return "ARMED";
        case StateId::ARMING: return "ARMING";
        case StateId::DISARMED: return "DISARMED";
        default: return "?";
    }
}

// Thread safe.
char const * ControllerSm::eventIdToString(EventId id)
{
    switch (id)
    {
        case EventId::ARM: return "ARM";
        case EventId::DISARM: return "DISARM";
        case EventId::DO: return "DO";
        default: return "?";
    }
}
